package manifests

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"gopkg.in/yaml.v2"
)

// extracts group, kind, version and name from a manifest obj
func GetGKVN(manifestObj map[interface{}]interface{}) string {

	// retrieves version, and defaults to ~G/~V if not
	version, ok := manifestObj["apiVersion"]
	if !ok {
		version = "~G/~V"
	}

	kind, ok := manifestObj["kind"]
	if !ok {
		kind = "~K"
	}

	var metadata map[interface{}]interface{}
	metadata = manifestObj["metadata"].(map[interface{}]interface{})

	var name string
	if ok {
		name, ok = metadata["name"].(string)
		if !ok {
			name = "~N"
		}
	} else {
		name = "~N"
	}

	if !strings.Contains(version.(string), "/") {
		version = fmt.Sprintf("~G/%s", version)
	}

	// prepare the final key
	GVKN := fmt.Sprintf("%s/%s|%s", version, kind, name)
	return GVKN
}

// we have a list of items, we need to split and get their individual gvkn
func GetNestedManifestsWithGVKN(manifestObj map[interface{}]interface{}) map[string]map[interface{}]interface{} {
	var items []interface{}
	var parsedItem map[interface{}]interface{}
	var GVKN string
	GVKNS := make(map[string]map[interface{}]interface{})

	items = manifestObj["items"].([]interface{})
	for _, item := range items {
		parsedItem = item.(map[interface{}]interface{})
		GVKN = GetGKVN(parsedItem)
		if len(GVKN) > 0 {
			GVKNS[GVKN] = parsedItem
		}
	}

	return GVKNS
}

// utility to add modifications on manifests
func ModifyAppliedManifests(content string, siteBuildPath string) []string {
	manifests := strings.Split(content, "\n---\n")
	kustomizeManifests := make(map[string]map[interface{}]interface{})

	// first split all manifests and unmarshall into objects
	for _, manifest := range manifests {
		var manifestObj map[interface{}]interface{}

		err := yaml.Unmarshal([]byte(manifest), &manifestObj)
		if err != nil {
			log.Println(fmt.Sprintf("Error parsing manifest: %s", err))
			os.Exit(1)
		}
		// add to the list of manifests with the generated key
		GVKN := GetGKVN(manifestObj)
		if GVKN == "~G/v1/List|~N" {
			nestedManifests := GetNestedManifestsWithGVKN(manifestObj)
			for k, v := range nestedManifests {
				kustomizeManifests[k] = v
			}
		} else {
			kustomizeManifests[GVKN] = manifestObj
		}
	}

	// now read all the manifests that have been generated by installer
	filepath.Walk(fmt.Sprintf("%s/blueprint/base/00_cluster", siteBuildPath), func(path string, info os.FileInfo, err error) error {
		if err == nil {
			// check if it is a file ending with yml/yaml and it is inside openshift or manifests directory
			if !info.IsDir() && (strings.Contains(path, "/openshift/") || strings.Contains(path, "/manifests/")) && (strings.HasSuffix(path, ".yaml") || strings.HasSuffix(path, ".yml")) {
				// read file content and unmarshal it
				manifestContent, err := ioutil.ReadFile(path)
				if err != nil {
					log.Println(fmt.Sprintf("Error reading manifest content: %s", err))
					os.Exit(1)
				}
				var manifestContentObj map[interface{}]interface{}
				err = yaml.Unmarshal(manifestContent, &manifestContentObj)
				if err != nil {
					log.Println(fmt.Sprintf("Error parsing manifest: %s", err))
					os.Exit(1)
				}

				GVKN := GetGKVN(manifestContentObj)
				var walkedManifests map[string]map[interface{}]interface{}
				if GVKN == "~G/v1/List|~N" {
					walkedManifests = GetNestedManifestsWithGVKN(manifestContentObj)
				} else {
					walkedManifests = make(map[string]map[interface{}]interface{})
					walkedManifests[GVKN] = manifestContentObj
				}

				// now compare each content with the ones from kustomize
				for k, v := range walkedManifests {
					kustomizedContent, ok := kustomizeManifests[k]
					if ok {
						if !reflect.DeepEqual(kustomizedContent, v) {
							log.Println(k)
							log.Println(v)
						}
					}
				}
			}
		} else {
			log.Println(fmt.Sprintf("Error walking on manifests directory: %s", err))
			os.Exit(1)
		}
		return nil
	})

	return manifests
}
