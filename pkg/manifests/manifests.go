package manifests

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"gopkg.in/yaml.v2"
)

// Generates an unique identifier based on the GKV (from K8s) + Name
func GetGKVN(manifestObj map[interface{}]interface{}) string {

	// retrieves version, and defaults to ~G/~V if not
	version, ok := manifestObj["apiVersion"]
	if !ok {
		version = "~G/~V"
	}

	kind, ok := manifestObj["kind"]
	if !ok {
		kind = "~K"
	}

	var metadata map[interface{}]interface{}
	var name string

	metadata, ok = manifestObj["metadata"].(map[interface{}]interface{})
	if ok {
		name, ok = metadata["name"].(string)
		if !ok {
			name = "~N"
		}
	} else {
		name = "~N"
	}

	if !strings.Contains(version.(string), "/") {
		version = fmt.Sprintf("~G/%s", version)
	}

	// prepare the final key
	GVKN := fmt.Sprintf("%s/%s|%s", version, kind, name)
	return GVKN
}

// we have a list of items, we need to split and get their individual gvkn
func GetNestedManifestsWithGVKN(manifestObj map[interface{}]interface{}) map[string]map[interface{}]interface{} {
	var items []interface{}
	var parsedItem map[interface{}]interface{}
	var GVKN string
	GVKNS := make(map[string]map[interface{}]interface{})

	items = manifestObj["items"].([]interface{})
	for _, item := range items {
		parsedItem = item.(map[interface{}]interface{})
		GVKN = GetGKVN(parsedItem)
		if len(GVKN) > 0 {
			GVKNS[GVKN] = parsedItem
		}
	}

	return GVKNS
}

// given a gvkn, gets a name from it
func NameFromGVKN(GVKN string) string {
	items := strings.Split(GVKN, "|")
	subItems := strings.Split(items[0], "/")
	name := fmt.Sprintf("%s-%s", subItems[2], items[1])
	if subItems[0] != "~G" {
		name = fmt.Sprintf("%s-%s", subItems[0], name)
	}
	return strings.ToLower(name)
}

// utility to merge manifests
func MergeManifests(content string, siteBuildPath string) string {
	manifests := strings.Split(content, "\n---\n")
	kustomizeManifests := make(map[string]map[interface{}]interface{})

	// first split all manifests and unmarshall into objects
	for _, manifest := range manifests {
		var manifestObj map[interface{}]interface{}

		err := yaml.Unmarshal([]byte(manifest), &manifestObj)
		if err != nil {
			log.Fatalf("Error parsing manifest: %s\n", err)
		}
		// add to the list of manifests with the generated key
		GVKN := GetGKVN(manifestObj)
		if GVKN == "~G/v1/List|~N" {
			nestedManifests := GetNestedManifestsWithGVKN(manifestObj)
			for k, v := range nestedManifests {
				kustomizeManifests[k] = v
			}
		} else {
			kustomizeManifests[GVKN] = manifestObj
		}
	}

	// now read all the manifests that have been generated by installer
	processedManifests := make(map[string]string)
	filepath.Walk(fmt.Sprintf("%s/blueprint/base/00_cluster", siteBuildPath), func(path string, info os.FileInfo, err error) error {
		if err == nil {
			// check if it is a file ending with yml/yaml and it is inside openshift or manifests directory
			if !info.IsDir() && (strings.Contains(path, "/openshift/") || strings.Contains(path, "/manifests/")) && (strings.HasSuffix(path, ".yaml") || strings.HasSuffix(path, ".yml")) {
				// read file content and unmarshal it
				manifestContent, err := ioutil.ReadFile(path)
				if err != nil {
					log.Fatalf("Error reading manifest content: %s\n", err)
				}
				var manifestContentObj map[interface{}]interface{}
				err = yaml.Unmarshal(manifestContent, &manifestContentObj)
				if err != nil {
					log.Fatalf("Error parsing manifest: %s\n", err)
				}

				GVKN := GetGKVN(manifestContentObj)
				var walkedManifests map[string]map[interface{}]interface{}
				if GVKN == "~G/v1/List|~N" {
					walkedManifests = GetNestedManifestsWithGVKN(manifestContentObj)
					for k, _ := range walkedManifests {
						processedManifests[k] = ""
					}
				} else {
					walkedManifests = make(map[string]map[interface{}]interface{})
					walkedManifests[GVKN] = manifestContentObj
					processedManifests[GVKN] = ""
				}

				// now compare each content with the ones from kustomize
				counter := 0
				for k, v := range walkedManifests {
					kustomizedContentObj, ok := kustomizeManifests[k]
					if ok {
						if !reflect.DeepEqual(kustomizedContentObj, v) {
							// do a backup of the original file
							if _, err := os.Stat(path); err == nil {
								err = os.Rename(path, fmt.Sprintf("%s.orig", path))
							}

							kustomizedString, err := yaml.Marshal(kustomizedContentObj)
							if err != nil {
								log.Fatalf("Error marshaling kustomized content: %s\n", err)
							}

							if len(walkedManifests) == 1 {
								// just rewrite with the original name
								err = ioutil.WriteFile(path, kustomizedString, 0644)
								if err != nil {
									log.Fatalf("Error writing new manifest content: %s\n", err)
								}
							} else {
								// rewrite with a prefix
								newPath := fmt.Sprintf("%02d_%s", counter, path)
								err = ioutil.WriteFile(newPath, kustomizedString, 0644)
								if err != nil {
									log.Fatalf("Error writing new manifest content: %s", err)
								}
								counter = counter + 1
							}
						}
					}
				}

			}
		} else {
			log.Fatalf("Error walking on manifests directory: %s\n", err)
		}
		return nil
	})

	// now find manifests not yet in assets dir and write them out
	counter := 0
	for k, v := range kustomizeManifests {
		_, ok := processedManifests[k]
		if !ok {
			// the manifest is not there, add it
			manifestName := fmt.Sprintf("99_%04d_%s.yaml", counter, NameFromGVKN(k))
			log.Printf("Blueprint added manifests %s, writing to %s\n", k, manifestName)

			newPath := fmt.Sprintf("%s/blueprint/base/00_cluster/manifests/%s", siteBuildPath, manifestName)

			// marshal the file to write
			kustomizedString, err := yaml.Marshal(v)
			if err != nil {
				log.Fatalf("Error marshing manifest: %s\n", err)
			}
			err = ioutil.WriteFile(newPath, kustomizedString, 0644)
			if err != nil {
				log.Fatalf("Error writing manifest: %s\n", err)
			}
			counter = counter + 1

		}
	}

	// finally, move content to final manifests
	os.RemoveAll(fmt.Sprintf("%s/final_manifests", siteBuildPath))
	err := os.Rename(fmt.Sprintf("%s/blueprint/base/00_cluster", siteBuildPath), fmt.Sprintf("%s/final_manifests", siteBuildPath))
	if err != nil {
		log.Fatalf("Error moving to final manifests folder: %s\n", err)
	} else {
		var builder strings.Builder

		fmt.Fprintf(&builder, "*** Manifest generation finished. You can run now: %s/requirements/openshift-install create cluster --dir=%s/final_manifests to create the site cluster ***\n", siteBuildPath, siteBuildPath)
		fmt.Fprintf(&builder, "If using UPI you can generate ignition files with: %s/requirements/openshift-install create ignition-configs --dir=%s/final_manifests\n", siteBuildPath, siteBuildPath)
		fmt.Fprintf(&builder, "If you are using baremetal automation you can deploy masters and workers with: ./knictl deploy_masters <site_name>, ./knictl deploy_workers <site_name>. Destroy the bootstrap VM once the deploy_workers command is initiated with: virsh destroy <bootstrap_vm_name>. You could destroy the cluster with: ./knictl destroy_cluster <site_name>\n")
		fmt.Fprintf(&builder, "A profile.env file has been generated inside %s/profile.env, you can source it before starting the openshift-install command\n", siteBuildPath)
		fmt.Fprintf(&builder, "In order to destroy the cluster you can run:  %s/requirements/openshift-install destroy cluster --dir %s/final_manifests", siteBuildPath, siteBuildPath)

		return builder.String()
	}

	// Should never get here
	return ""
}
